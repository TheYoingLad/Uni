module gy04 where

open import Lib hiding (_+‚àû_; coite-‚Ñï‚àû; ‚ä§Œ∑)

open import Lib.Containers.List hiding (zipWith; head; tail)
open import Lib.Containers.Stream hiding (zipWith; coiteStream)

---------------------------------------------------------
-- t√≠pusok Œ∑-szab√°lyai
---------------------------------------------------------
{-
Eml√©keztet≈ë: A Œ∑-szab√°ly azt mondja meg, hogy mit tegy√ºnk, ha destruktorra alkalmazunk konstruktort.
Pl. f√ºggv√©nyek eset√©n (Œª a ‚Üí f a) ‚â° f, ahol a f√ºggv√©nyalkalmaz√°s a destruktor √©s a Œª a konstruktor.

Term√©szetesen m√°s t√≠pusoknak is ugyan√∫gy van Œ∑-szab√°lya.

Vegy√ºk p√©ldak√©nt a ‚ä§-ot:
Destruktora: ite‚ä§ : A ‚Üí ‚ä§ ‚Üí A

Ez alapj√°n az Œ∑-szab√°ly az al√°bbi lesz:
ite‚ä§ tt x ‚â° x

Ez term√©szetesen Agd√°ban bizony√≠that√≥ is.
-}

ite‚ä§ : ‚àÄ{i}{A : Set i} ‚Üí A ‚Üí ‚ä§ ‚Üí A
ite‚ä§ x _ = x

‚ä§Œ∑ : ‚àÄ{x} ‚Üí ite‚ä§ tt x ‚â° x
‚ä§Œ∑ = refl

{-
Ahogy eml√©keztek r√°, a ‚ä§ Œ∑-szab√°lya √∫gy n√©z ki, hogy ‚àÄ a ‚Üí a ‚â° tt,
teh√°t itt is igaz lesz, hogy egy t√≠pusnak t√∂bb egym√°ssal ekvivalens Œ∑-szab√°lya lehet.

N√©zz√ºk √∫jra p√©ldak√©nt a Bool t√≠pust. A Œ≤-szab√°lyai a k√∂vetkez≈ëk voltak:
if true then u else v ‚â° u
if false then u else v ‚â° v

Mi lehet az Œ∑-szab√°ly? Hogy lehet "destruktorra alkalmazni konstruktort" ilyen esetben?
Az if_then_else_ eset√©n a "then" √©s az "else" √°gban l√©v≈ë dolgok tetsz≈ëleges √©rt√©kek lehetnek;
ide ak√°r konstruktort is be lehet √≠rni. Teh√°t √∫gy lehet fel√©p√≠teni az Œ∑-szab√°lyokat, hogy a destruktor megfelel≈ë
helyeire be√≠rom az azonos t√≠pus konstruktorait.
Bool eset√©n ez azt jelenti, hogy az if_then_else_-ben a m√°sodik √©s harmadik helyre kell a Bool k√©t konstruktor√°t √≠rni.
Ezen fel√ºl √∫gy kell be√≠rni a k√©t konstruktort, hogy alapvet≈ëen az "identit√°s" f√ºggv√©nyt kapjuk az adott t√≠puson.
Bool eset√©n teh√°t √∫gy kell az if_then_else_-et felparam√©terezni, hogy a false-ra false legyen az eredm√©ny, true-ra pedig true.

Ez alapj√°n mi lesz a Bool-oknak egy lehets√©ges Œ∑-szab√°lya?
V√°lasz:
if x then true else false ‚â° x
iteBool true false x = x

Ugyanezt az ismert ùüõ t√≠puson is el lehet j√°tszani.
data ùüõ : Set where
  a1 a2 a3 : ùüõ

Ismert a destruktor: iteùüõ : A ‚Üí A ‚Üí A ‚Üí ùüõ ‚Üí A

Mi lesz a ùüõ Œ∑-szab√°lya?
V√°lasz:
iteùüõ a1 a2 a3 x = x

Term√©szetes sz√°mokon a helyzet szint√©n nem v√°ltozik.
Ismert a destruktor: ite‚Ñï : A ‚Üí (A ‚Üí A) ‚Üí ‚Ñï ‚Üí A

Mi lesz ‚Ñï Œ∑-szab√°lya?
V√°lasz:
ite‚Ñï zero suc x = x
-}

---------------------------------------------------------
-- positivity
---------------------------------------------------------

{-

  egy t√≠pus (D : Set) defin√≠ci√≥jakor egy konstruktorban √°ltal√°nos alakja:
 
  ci : (y1 : B1) -> ... -> (ym : Bm) -> D

  vagyis a ci kap y1,y2,y3,... √©rt√©keket amik t√≠pusa B1,B2,...

  ezekkel kapcsolatban az a megk√∂t√©s hogy B1,B2,B3,... ban D csak *pozit√≠v* helyen szerepelhet 

  Mi a pozit√≠v hely?

  Egy f√ºggv√©ny t√≠pusban : (A ‚Üí B) 

  A negat√≠v helyen van, B pozit√≠v

  (A ‚Üí (B ‚Üí C))

  A, B negat√≠v, C poziv√≠t

  (A ‚Üí B) ‚Üí C

  A negat√≠v, B √©s C poziv√≠t

  Vagyis ci p√©ld√°ul nem lehet : (D ‚Üí A) ‚Üí D
  mert a (D ‚Üí A)-ben

  M√©g pontosabban
  Szigor√∫an pozit√≠v : 

  data D : Set where
    c1 : (y‚ÇÅ : A‚ÇÅ ‚Üí D) ‚Üí (y‚ÇÇ : A‚ÇÇ ‚Üí D) ‚Üí (y‚ÇÉ : A‚ÇÉ ‚Üí D) ‚Üí D
    ...
  Ahol A·µ¢-ben NINCS D

-}

-- Mi√©rt nem enged agda bizonyos t√≠pusokat defini√°lni? Pl. alapesetben az al√°bbit sem.

{-# NO_POSITIVITY_CHECK #-}
data Tm : Set where
  lam : (Tm ‚Üí Tm) ‚Üí Tm

-- FELADAT: Tm-b≈ël adjuk vissza a lam √©rt√©k√©t.
-- Az applik√°ci√≥ √°ltal√°ban app : Tm ‚Üí Tm ‚Üí Tm , mert ugye k√©t termet applik√°lunk egym√°sra, √©s a bal oldali egy f√ºggv√©ny (ha vannak t√≠pusaink)
-- Itt lam egy f√ºggv√©nyt t√°rol, mert ugye azt reprez√°lt√°lja (lam = lambda), √©s mi kicsomagonjuk ezt a f√ºggv√©nyt √©s a kapott Tm-re applik√°ljuk
app : Tm ‚Üí (Tm ‚Üí Tm)
app (lam f) t = f t

-- Ez az √©rt√©k egy olyan f√ºggv√©ny ami a kapott √©rt√©ket √∂nmag√°ra applik√°lja
-- Agd√°ban :  selfapp = \t -> t t  -- Mi√©rt nem m√ºk√∂dik ez Agd√°ban? Seg√≠ts√©g mi lenne selfapp t√≠pusa
self-apply : Tm
self-apply = lam (Œª t ‚Üí app t t)

-- C-c C-n this:
-- √ârdekel mi√©rt mukodik? keres r√° Y kombin√°tor, vagy itt : https://www.youtube.com/watch?v=9T8A89jgeTI
Œ© : Tm
Œ© = app self-apply self-apply

{-# NO_POSITIVITY_CHECK #-}
data Weird : Set where
  foo : (Weird ‚Üí ‚ä•) ‚Üí Weird
  -- Hogy kell elolvasni magyarul a "foo" konstruktort?

unweird : Weird ‚Üí ‚ä•
unweird (foo x) = x (foo x)

-- ‚ä• t√≠pus√∫ √©rt√©knek TILOS l√©teznie, ellenkez≈ë esetben a rendszer inkonzisztens, nem haszn√°lhat√≥ SEMMIRE.
bad : ‚ä•
bad = unweird (foo unweird)

---------------------------------------------------------
-- coinductive types ~~v√©gtelen f√°k 
---------------------------------------------------------

{-
record Stream (A : Set) : Set where
  coinductive
  field
    head : A
    tail : Stream A
open Stream
-}
-- check that the type of head : Stream A ‚Üí A
--                        tail : Stream A ‚Üí Stream A

-- Ez a t√≠pus l√©nyeg√©ben a v√©gtelen list√°kat k√≥dolja el.
-- Ebben v√©ges lista nincs benne, csak v√©gtelen!


-- Copattern matching!
-- FELADAT: Add meg azt a v√©gtelen list√°t, amely csak 0-kb√≥l √°ll.
zeroes : Stream ‚Ñï
head zeroes = zero
tail zeroes = zeroes

-- zeroes' : Stream ‚Ñï
-- zeroes' = 0 :: zeroes'     ez nem lesz helyes

-- Honnan tudja agda, hogy ez tot√°lis?
-- Termination checker nem tud futni, hiszen a lista v√©gtelen.
-- Productivity checker

-- by pattern match on n
-- FELADAT: Add meg azt a list√°t, amely n-t≈ël 0-ig sz√°mol vissza egyes√©vel.
countDownFrom : ‚Ñï ‚Üí List ‚Ñï
countDownFrom zero = []
countDownFrom (suc n) = (suc n) ‚à∑ (countDownFrom n)

-- from n is not by pattern match on n
-- copattern match on Stream
-- FELADAT: Adjuk meg azt a v√©gtelen list√°t, amely n-t≈ël 1-es√©vel felfel√© sz√°mol!
from : ‚Ñï ‚Üí Stream ‚Ñï
head (from n) = n
tail (from n) = from (suc n)

-- pointwise addition
zipWith : {A B C : Set} ‚Üí (A ‚Üí B ‚Üí C) ‚Üí Stream A ‚Üí Stream B ‚Üí Stream C
head (zipWith f as bs) = f (head as) (head bs)
tail (zipWith f as bs) = zipWith f (tail as) (tail bs)

-- Defini√°lhat√≥-e a filter sima list√°kon?
filterL : {A : Set} ‚Üí (A ‚Üí Bool) ‚Üí List A ‚Üí List A
filterL p [] = []
filterL p (a ‚à∑ as) = if p a then a ‚à∑ (filterL p as) else filterL p as

-- Defini√°lhat√≥-e a filter Stream-eken?
filterS : {A : Set} ‚Üí (A ‚Üí Bool) ‚Üí Stream A ‚Üí Stream A
head (filterS p xs) = if p (head xs) then head xs else {!  !}
tail (filterS p xs) = filterS p (tail xs)

-- one element from the first stream, then from the second stream, then from the first, and so on
interleave : {A : Set} ‚Üí Stream A ‚Üí Stream A ‚Üí Stream A
head (interleave as bs) = head as
tail (interleave as bs) = head bs ‚à∑ (interleave (tail as) (tail bs))

-- get the n^th element of the stream
get : {A : Set} ‚Üí ‚Ñï ‚Üí Stream A ‚Üí A
get zero as = head as
get (suc n) as = get n (tail as)

-- byIndices [0,2,3,2,...] [1,2,3,4,5,...] = [1,3,4,2,...]
byIndices : {A : Set} ‚Üí Stream ‚Ñï ‚Üí Stream A ‚Üí Stream A
head (byIndices is as) = get (head is) as
tail (byIndices is as) = byIndices (tail is) (tail as)

-- ite‚Ñï : (A : Set) ‚Üí A ‚Üí (A ‚Üí A)  ‚Üí ‚Ñï ‚Üí A
--        \______________________/
--         ‚Ñï - algebra

-- Mi lesz a Stream konstruktora?
coiteStream : {A B : Set} ‚Üí (B ‚Üí A) ‚Üí (B ‚Üí B) ‚Üí B ‚Üí Stream A
--               \_______________________________/
--                        Stream A - coalgebra
head (coiteStream chead ctail seed) = chead seed
tail (coiteStream chead ctail seed) = coiteStream chead ctail (ctail seed)

-- ex: redefine the above functions using coiteStream

from' : ‚Ñï ‚Üí Stream ‚Ñï
from' n = coiteStream (Œª m ‚Üí m) (Œª m ‚Üí suc m) n

-- ex: look at conatural numbers in Thorsten's book and do the exercises about them

-- simple calculator (internally a number, you can ask for the number, add to that number, multiply that number, make it zero (reset))
record Machine : Set where
  coinductive
  field
    getNumber : ‚Ñï
    add       : ‚Ñï ‚Üí Machine
    mul       : ‚Ñï ‚Üí Machine
    reset     : Machine
open Machine

calculatorFrom : ‚Ñï ‚Üí Machine
getNumber (calculatorFrom n) = n
add (calculatorFrom n) m = calculatorFrom (n + m)
mul (calculatorFrom n) m = calculatorFrom (n * m)
reset (calculatorFrom n) = calculatorFrom zero  

c0 c1 c2 c3 c4 c5 : Machine
c0 = calculatorFrom 0
c1 = add c0 3
c2 = add c1 5
c3 = mul c2 2
c4 = reset c3
c5 = add c4 2

-- FELADAT: K√©sz√≠ts√ºnk egy csokiautomat√°t.
-- A g√©pbe tudunk p√©nzt dob√°lni (ez legyen ‚Ñï, ennyit adjunk hozz√° a jelenlegi kredit√ºnkh√∂z).
-- A tranzakci√≥t meg tudjuk szak√≠tani, a kredit 0 lesz √©s visszaadja a p√©nz√ºnket.
-- Legyen 3 term√©k√ºnk, ezek egyenk√©nt ker√ºlnek valamennyibe √©s van bel≈ël√ºk a g√©pben valamennyi.
-- + Twix: 350-be ker√ºl, kezdetben van a g√©pben 50 darab.
-- + Croissant: 400-ba ker√ºl, kezdetben van 75 darab.
-- + Snickers: 375-be ker√ºl, kezdetben van 60 darab.
-- Tudunk 1 term√©ket v√°s√°rolni, ha van el√©g bedobott p√©nz√ºnk, ekkor a darabsz√°mb√≥l vonjunk le egyet (ha lehet) √©s adjuk vissza a visszaj√°r√≥t, a kreditet null√°zzuk le.
-- A g√©p tartalm√°t √∫jra tudjuk t√∂lteni, ekkor twix-b≈ël legyen √∫jra 50 darab, croissant-b√≥l 75, snickers-b≈ël pedig 60.

{- record CsokiGep : Set where
  coinductive
  field
    kredit          : ‚Ñï
    twix            : ‚Ñï
    Croissant       : ‚Ñï
    Snickers        : ‚Ñï
    megszakit       : CsokiGep
open CsokiGep -}



-- conatural numbers
{-
record ‚Ñï‚àû : Set where
  coinductive
  field
    pred‚àû : Maybe ‚Ñï‚àû
open ‚Ñï‚àû
-}

_+‚àû_ : ‚Ñï‚àû ‚Üí ‚Ñï‚àû ‚Üí ‚Ñï‚àû
pred‚àû (x +‚àû x‚ÇÅ) = nothing

-- Ez a f√ºggv√©ny l√©tezik, ezzel lehet megn√©zni
-- egy conat t√©nyleges √©rt√©k√©t.
-- Az els≈ë param√©ter a fuel, maximum ezt a term√©szetes sz√°mot tudja visszaadni.
-- M√°sodik param√©ter a conat, amire k√≠v√°ncsiak vagyunk.
-- √ârtelemszer≈±en ‚àû-re mindig nothing az eredm√©ny.
{-
‚Ñï‚àû‚Üí‚Ñï : ‚Ñï ‚Üí ‚Ñï‚àû ‚Üí Maybe ‚Ñï
‚Ñï‚àû‚Üí‚Ñï zero _ = nothing
‚Ñï‚àû‚Üí‚Ñï (suc n) c with pred‚àû c
... | zero‚àû = just 0
... | suc‚àû b with ‚Ñï‚àû‚Üí‚Ñï n b
... | nothing = nothing
... | just x = just (suc x)
-}

coite‚Ñï‚àû : {B : Set} ‚Üí (B ‚Üí Maybe B) ‚Üí B ‚Üí ‚Ñï‚àû
pred‚àû (coite‚Ñï‚àû cpred n) = just (coite‚Ñï‚àû cpred n)

-- TODO, further exercises: network protocols, simple machines: chocolate machine (input: coin, getChocolate, getBackCoins, output: error, chocolate, money back), some Turing machines, animations, IO, repl, shell
  